"""
author: Ben Comer (Georgia Tech)
email: benmcomer@gmail.com
"""
import os
import subprocess
from ase.calculators.calculator import FileIOCalculator
#from ase.utils.timing import Timer
from utilities import h2gpts
import numpy as np
from ase.units import Bohr, Hartree
from ion import write_ion

all_properties = ['energy', 'forces', 'stress', 'dipole',
                  'charges', 'magmom', 'magmoms', 'free_energy']


all_changes = ['positions', 'numbers', 'cell', 'pbc',
               'initial_charges', 'initial_magmoms']


class SPARC(FileIOCalculator):
    """
    ase calculator class for SPARC
    """
    
    implemented_properties = ['energy', 'forces']

    default_parameters = {
            # 'label': 'sprc-calc',
            # 'calculation_directory':'sprk.log',
            
            
            'BOUNDRY_CONDITION': 2,
            'EXCHAGE_CORRELATION': 'LDA_PZ',  # 'LDA'
            'KPOINT_GRID': (1, 1, 1),
            'BETA': 1000.000000,
            'CHEN_DEGREE': 20,
            'NSTATES': None,
            'MAXIT_SCF': 100,
            'TOL_SCF': 1.00E-06,
            'TOL_POISSON': 1.00E-08,
            'TOL_LANCZOS': 1.00E-02,
            'TOL_PSEUDOCHARGE': 1.00E-08,
            'MIXING_PARAMETER': 0.30,
            'MIXING_HISTORY': 7,
            'PULAY_FREQUENCY': 1,
            'PULAY_RESTART': 0,
            'REFERENCE_CUTOFF': 0.50,
            'RHO_TRIGER': 3,
            'PRINT_FORCES': 0,
            'PRINT_ATOMS': 0,
            'PRINT_EIGEN': 0,
            'PRINT_DENSITY': 0,
            'PSEUDOPOTENTIAL_LOCAL': 4,
            # 'PSEUDOPOTENTIAL_FILE': '../psdpots/psd_oncv_{}.pot',
            'OUTPUT_FILE': None,
            
            'NP_KPOINT_PARAL': None,
            'NP_BAND_PARAL': None,
            'NP_DOMAIN_PARAL': None,
            'NP_DOMAIN_PHI_PARAL': None,
                        }
    
    equivalencies = {
            'xc': 'EXCHAGE_CORRELATION',
            'kpts': 'KPOINT_GRID',
            'nbands': 'NSTATES',
            
            'gpts': 'FD_GRID'
            
            
            }
    misc = {'h': 'grid_spacing', }
    
    def __init__(self, restart=None, ignore_bad_restart=False,
                 label='sprc-calc', atoms=None, command=None,
                 write_defaults=False, verbosity='normal', **kwargs):
        for key in kwargs:
            if key not in self.default_parameters.keys() + \
            self.equivalencies.keys() + self.misc.keys() and \
            key.upper() not in self.default_parameters.keys():
                raise TypeError('Unknown input parameter {}'.format(key))
                
        #self.timer = Timer()
        self.initialized = False
        self.write_defaults = write_defaults
        self.verbosity = verbosity
        FileIOCalculator.__init__(self, restart, ignore_bad_restart, label,
                                  atoms, command)
        self.atoms = atoms
        self.num_calculations = 0
        if 'PRINT_FORCES' not in kwargs and 'PRINT_ATOMS' not in kwargs and \
        'PRINT_EIGEN' not in kwargs and 'PRINT_DENSITY' not in kwargs:
            if verbosity == 'low':
                pass
            else:
                kwargs['PRINT_FORCES'] = 1
                kwargs['PRINT_ATOMS'] = 1
                if verbosity == 'high':
                    kwargs['PRINT_EIGEN'] = 1
                    kwargs['PRINT_DENSITY'] = 1
        self.set(**kwargs)
       # self.write_input(atoms=atoms,write_defaults=write_defaults, **kwargs)

 
    def write_input(self, atoms, write_defaults=False,
                    verbosity='normal', **kwargs):
        
        if atoms is None:
            raise Exception('Atoms object is required to creat input file')
        FileIOCalculator.write_input(self, atoms=atoms)
        os.chdir(self.directory)
        if [a == 90 for a in atoms.get_cell_lengths_and_angles()[3:]]\
               != [True, True, True]:  # check cell is a rectangle
           raise NotImplementedError("""Unit cells must be rectangular\
, non-orthogonoal cells are currently under development'""")

        f = open(self.label + '.inpt','w')
        
        
        f.write('# Input File Generated By SPARC ASE Calculator #\n')
        f.write('NTYPES: '+ str(len(set(atoms.get_chemical_symbols()))) + '\n')
        # input the cell
        # if the system has no cell, give 6 A of space on each side
        if 'CELL' in kwargs:
            f.write('CELL:')
            for i,length in enumerate(kwargs['CELL']):
                f.write(' '+length[i])
        elif round(float(np.linalg.norm(atoms.cell)), 1) == 0:
            f.write('CELL:')
            cell = np.eye(3) * (np.max(atoms.positions, axis=0) + (6, 6, 6))
            atoms.set_cell(cell)
            for cell_param in atoms.get_cell_lengths_and_angles()[0:3]:
                f.write(' ' + str((cell_param) / Bohr))
            atoms.center()
        elif [a == 90 for a in atoms.get_cell_lengths_and_angles()[3:]] \
               == [True, True, True]:  # check cell is a rectangle
            f.write('CELL:')
            for length in atoms.get_cell_lengths_and_angles()[:3]:
                f.write(' ' + str(length / Bohr))
        else:
            raise NotImplementedError("""Unit cells must be rectangular\
, non-orthogonoal cells are currently under development'""")
        f.write('\n')
        # input finite difference grid
        f.write('FD_GRID:')
        if 'FD_GRID' in kwargs:  # fix to be able to take gts or lower case CELL
            for n_pts in kwargs['CELL']:
              f.write(' ' + str(n_pts))
        elif 'h' in kwargs:
            fd_grid = h2gpts(kwargs['h'], atoms.cell, idiv=1)
            for n_pts in fd_grid:
              f.write(' ' + str(n_pts))
        elif 'gpts' in kwargs:
            for n_pts in kwargs['gpts']:
              f.write(' ' + str(n_pts))
        else:  # default of 0.2 A was chosen
            if 'cell' not in locals():
                cell = atoms.cell
            fd_grid = h2gpts(0.2, cell, idiv=1)
            for n_pts in fd_grid:
               f.write(' ' + str(n_pts))
        f.write('\n')
        
        # deal with pseudopotential file path
        if 'PSEUDOPOTENTIAL_FILE' in kwargs:  # fix to allow lower case
            f.write('PSEUDOPOTENTIAL_FILE: ')
            for psp_path in kwargs['PSEUDOPOTENTIAL_FILE']:
                f.write(psp_path + ' ')
            f.write('\n')
            """
            If issue with pseudos not being in an absolute path and the
            limited length of file location is fixed this code will become
            useful
        elif 'PSP_PATH' in os.environ:
            f.write('PSEUDOPOTENTIAL_FILE: ')
            for element in sorted(list(set(atoms.get_chemical_symbols()))):
                psp_path = os.path.join(os.environ['PSP_PATH'],'psd_oncv_'+element+'.pot')
                f.write(psp_path+' ')
            f.write('\n')
            """
        elif 'PSP_PATH' in os.environ:
            f.write('PSEUDOPOTENTIAL_FILE: ')
            for element in sorted(list(set(atoms.get_chemical_symbols()))):
                os.system('cp $PSP_PATH/psd_oncv_' + element + '.pot .')
                psp_path = 'psd_oncv_' + element + '.pot'
                f.write(psp_path + ' ')
            f.write('\n')
        elif write_defaults is True:
            f.write('PSEUDOPOTENTIAL_FILE: ')
            for element in sorted(list(set(atoms.get_chemical_symbols()))):
                f.write('../psdpots/psd_oncv_' + element + '.pot ')
            f.write('\n')

        # xc should be put in separately
        if 'EXCHAGE_CORRELATION' not in [a.upper() for a in kwargs]:
            f.write('EXCHAGE_CORRELATION: ' +
                    self.default_parameters['EXCHAGE_CORRELATION'] + '\n')
        else:
            f.write('EXCHAGE_CORRELATION: ' +
                    kwargs['EXCHAGE_CORRELATION'] + '\n')

        # check if the user has defined some print settings, these override verbosity inputs
        non_standard_verbosity_input = [a for a in kwargs if 'PRINT' in a]
        non_standard_verbosity_input = non_standard_verbosity_input != []
        if verbosity == 'low' and not non_standard_verbosity_input:
            pass
        elif verbosity == 'normal' and not non_standard_verbosity_input:
            f.write('PRINT_FORCES: 1\nPRINT_ATOMS: 1\n')
        elif verbosity == 'high' and not non_standard_verbosity_input:
            f.write('PRINT_FORCES: 1\nPRINT_ATOMS: 1\n \
                    PRINT_EIGEN: 1\nPRINT_DENSITY: 1\n')
  
        # take care of all the other parameters, this does most of the work    
        for key,value in kwargs.items():
            if key in self.equivalencies:
                f.write(self.equivalencies[key]+ ': ' + str(value) + '\n')
            elif key in self.default_parameters.keys():
                if ((self.default_parameters[key.upper()] != value) or write_defaults==True)\
                   and value != None:
                    f.write(key.upper() + ': ' + str(value) + '\n')
            #f.write('\n')
        
        #If the user wants the defaults explicitly in the input file
        if write_defaults is True:
            for key, value in self.default_parameters.items():
                if key not in kwargs.keys() and key !='EXCHAGE_CORRELATION' \
                and value != None:
                    f.write(key + ': '+str(value))
                f.write('\n')
        #write the atomic positions file (.ion file)
        write_ion(open(self.label + '.ion','w'),atoms)

 
    def calculate(self, atoms=None, properties=['energy'],
                  system_changes=all_changes):
        """Do the calculation.

        properties: list of str
            List of what needs to be calculated.  Can be any combination
            of 'energy', 'forces', 'stress', 'dipole', 'charges', 'magmom'
            and 'magmoms'.
        system_changes: list of str
            List of what has changed since last calculation.  Can be
            any combination of these six: 'positions', 'numbers', 'cell',
            'pbc', 'initial_charges' and 'initial_magmoms'.

        Subclasses need to implement this, but can ignore properties
        and system_changes if they want.  Calculated properties should
        be inserted into results dictionary like shown in this dummy
        example::

            self.results = {'energy': 0.0,
                            'forces': np.zeros((len(atoms), 3)),
                            'stress': np.zeros(6),
                            'dipole': np.zeros(3),
                            'charges': np.zeros(len(atoms)),
                            'magmom': 0.0,
                            'magmoms': np.zeros(len(atoms))}

        """
        #FileIOCalculator.calculate(self,atoms=atoms)
        if atoms is not None:
            self.atoms = atoms.copy()
        else:
            atoms=self.atoms
        self.write_input(atoms=atoms, verbosity=self.verbosity, **self.parameters)
        if self.command is None:
            raise RuntimeError(
                'Please set ${} environment variable '
                .format('ASE_' + self.name.upper() + '_COMMAND') +
                'or supply the command keyword')
        #This is designed only for PACE at the moment
        if 'PBS_NODEFILE' in os.environ:
            f = open(os.environ['PBS_NODEFILE'],'r')
            nodes = len(f.readlines())
            self.num_nodes = nodes
            #print('mpirun -np '+str(self.num_nodes)+' '
            #                        +self.command + ' -name ' + self.prefix)
        #command = self.command.replace('PREFIX', self.prefix)
        #errorcode = subprocess.call(command, shell=True, cwd=self.directory)
            errorcode = 1
            while errorcode !=0:
            #time.sleep(2) # 2 second cushion on either side for safety, can be removed later
                errorcode = subprocess.call('mpirun '
                                    +'-env MV2_ENABLE_AFFINITY=1 -env '
                                    +'MV2_CPU_BINDING_POLICY=bunch'
                                    +' -np ' + str(self.num_nodes) + ' '
                                    +self.command + ' -name ' + self.prefix,
                                    #+' -log_summary > mpi.log'+
                                    shell=True, cwd=self.directory)
                self.concatinate_output()
            #time.sleep(2)
        else:
            errorcode = subprocess.call(self.command + ' -name ' + self.prefix,
                                    shell=True, cwd=self.directory)

        if errorcode:
            raise RuntimeError('{} in {} returned an error: {}'
                               .format(self.name, self.directory, errorcode))
        self.concatinate_output()
        self.read_results()
        self.num_calculations += 1
        
        
    def read_results(self):
        """"
        # find the most recently modified output file to read
        time = -10**6
        for output_file in os.listdir('./'):
            if self.label in output_file and 'out' in output_file:
                new_time = os.path.getmtime(output_file)
                if new_time > time:
                    time = new_time
                    output = output_file
        """
        output = self.label + '.out'
        # read and parse output
        f = open(output,'r')
        log_text = f.read()
        body = log_text.rsplit('Timing info')[-2]
        #energy_force_block = body.rsplit('Energy and atomic forces')[-1]
        energy_force_block = body.rsplit('Energy')[-1]
        energy_force_block = energy_force_block.split('\n')
        output_energies_in_order = []
        # read off energies printed by SPARC, energies are in Ha
        for energy in energy_force_block[2:8]:
            _,eng = energy.split(':')
            output_energies_in_order.append(float(eng.strip()[:-5]))
        # read forces, forces are in Ha/Bohr
        if 'PRINT_FORCES: 1' in log_text:
            forces = np.empty((len(self.atoms),3))
            for i,force in enumerate(energy_force_block[9:-5]):
                forces[i,:] = [float(a) for a in force.split()]
        

        free_eng, band_struc_eng, xc_eng, self_corr_eng, \
        Entr_kbt, fermi_level = output_energies_in_order
        self.results = {
                'energy': free_eng * Hartree,
                'free_energy': free_eng * Hartree,
                'forces': forces * Hartree * Bohr,
                }
        #print('output read')
        self.fermi_level = fermi_level
       

    def set_atoms(self, atoms):
        if (atoms != self.atoms):
            self.reset()
        self.atoms = atoms.copy()

    def get_atoms(self):
        atoms = self.atoms.copy()
        atoms.set_calculator(self)
        return atoms

    def get_fermi_level(self):
        if self.results == {}:
            self.calculate()
        return self.fermi_level

    def get_forces(self, atom=None):
        #print('force call')
        if self.parameters['PRINT_FORCES']==0:
            raise Exception('verbosity must be set to normal, or PRINT_FORCES must be set to 1')
        if self.results == {}:
            self.calculate()
        return self.results['forces']
        #return self.get_property('forces', atoms)

    def concatinate_output(self):
        files = os.listdir('.')
        files.sort()
        for item in files:
            if item.startswith(self.label) and 'out' in item and \
               item != self.label + '.out':
                f = open(self.label + '.out', 'a')
                g = open(item, 'r')
                text = g.read()
                f.write('\n' + text)
                os.remove(item)
 
#   def get_number_of_grid_points(): implement in the future
        
        
        
        
        
        
        
        
        
        
        
        

            
